# Copyright 2012 10gen, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#!/usr/bin/env python

# anatomy of a clock skew document:
# document = {
#    "type" = "clock_skew"
#    "server_name" = "name"
#    "partners" = {
#          server_name : [ td1, td2, ... ]
#          }
#     }

import pymongo
import logging
from datetime import datetime
from datetime import timedelta


def server_clock_skew(db, collName):
    """Given the mongodb entries generated by logl,
    attempts to detect and resolve clock skew
    across different servers."""
    logger = logging.getLogger(__name__)
    for doc_a in db[collName + ".servers"].find():
        a = doc_a["server_name"]
        if a == "unknown":
            logger.debug("Skipping unknown server")
            continue
        skew_a = db[collName + ".clock_skew"].find_one({"server_name": a})
        if not skew_a:
            skew_a = clock_skew_doc(a)
        for doc_b in db[collName + ".servers"].find():
            b = doc_b["server_name"]
            logger.info("Finding clock skew for {0} - {1}...".format(a, b))
            if b == "unknown":
                logger.debug("Skipping unknown server")
                continue
            if a == b:
                logger.debug("Skipping identical server")
                continue
            if b in skew_a["partners"]:
                logger.debug("Clock skew already found for this server")
                continue
            list = detect(a, b, db, collName)
            skew_a["partners"][b] = list
            skew_b = db[collName + ".clock_skew"].find_one({"server_name":b})
            if not skew_b:
                skew_b = clock_skew_doc(b)
            # flip according to sign convention for other server:
            # if server is ahead, +t
            # if server is behind, -t
            skew_b["partners"][a] = []
            if skew_a["partners"][b]:
                for t in skew_a["partners"][b]:
                    t = -t
                    logger.debug("flipped one");
                    skew_b["partners"][a].append(t)
            db[collName + ".clock_skew"].save(skew_a)
            db[collName + ".clock_skew"].save(skew_b)

def detect(a, b, db, collName):
    """Detect any clock skew between a and b,
    and return it as a list of integers representing skew
    in seconds.  If unable to detect skew, return None."""
    entries_a = db[collName + ".entries"]
    entries_b = db[collName + ".entries"]
    cursor_a = entries_a.find({"type" : "status", "origin_server" : a, "info.server" : b})
    cursor_b = entries_b.find({"type" : "status", "origin_server" : b, "info.server" : "self"})
    cursor_a.sort("date")
    cursor_b.sort("date")
    logger = logging.getLogger(__name__)
    logger.debug("Detecting clock skew for pair {0} - {1}...".format(a, b))
    skews = []
    min_time = timedelta(seconds=2)
    try:
        a_1 = cursor_a.next()
        b_1 = cursor_b.next()
    except StopIteration:
        logger.debug("Cursors are empty!")
        return None
    # take and compare two consecutive entries from each cursor
    while True:
        try:
            logger.debug("Using next set of entries")
            a_2 = cursor_a.next()
            b_2 = cursor_b.next()
            # if first entries do not match, call mismatch
            mismatch(cursor_a, cursor_b)
            if a_1["info"]["state_code"] != b_1["info"]["state_code"]:
                clone_a = cursor_a
                clone_a_2 = a_2
                clone_a_1 = a_1
                while a_1["info"]["state_code"] != b_1["info"]["state_code"]:
                    logger.debug("first entries do not match")
                    a_1 = a_2
                    if not a.alive:
                        break
                    a_2 = cursor_a.next()
            # if first entries still do not match, reset A and advance B
            if a_1["info"]["state_code"] != b_1["info"]["state_code"]:
                # reset a
                cursor_a = clone_a
                a_1 = clone_a_1
                a_2 = clone_a_2
                # advance through B
                # if B runs out,
            # if first entries match but not second ones, advance A and B
            if (a_1["info"]["state_code"] == b_1["info"]["state_code"]) and (a_2["info"]["state_code"] != b_2["info"]["state_code"]):
                logger.debug("first entries match, but not second ones")
                continue
            # if both first and second entries match, take clock skew
            # (fix me so I work better please...)
            if (a_1["info"]["state_code"] == b_1["info"]["state_code"]) and (a_2["info"]["state"] == b_2["info"]["state"]):
                logger.debug("Both entries match!  Calculating clock skew")
                td1 = b_1["date"] - a_1["date"]
                td2 = b_2["date"] - a_2["date"]
                # if td1 and td2 are wildly different, append both
                diff = td1 - td2
                if abs(diff) < min_time:
                    logger.debug("td1 and td2 agree.  Big enough for clock skew?")
                # they agree.  But big enough for clock skew?
                    if abs(td1) > min_time:
                        logger.debug("clock skew found!")
                        if not in_skews(td1, skews):
                            logger.debug("appending new value")
                            skews.append(td1)
                        else:
                            logger.debug("value already in list")
                    else:
                        logger.debug("Not big enough for clock skew, ignore")
                else:
                    logger.debug("Found two different clock skew values")
                    if not in_skews(td1, skews):
                        skews.append(td1)
                    if not in_skews(td1, skews):
                        skews.append(td2)
            a_1 = a_2
            b_1 = b_2
        except StopIteration:
            logger.debug("Out of entries, return skew information")
            if not skews:
                return skews
            list = []
            for t in skews:
                list.append(timedelta_to_int(t))
            return list

def in_skews(t, skews):
    """If this entry is not close in value
    to an existing entry in skews, return False"""
    for skew in skews:
        if abs(t) - abs(skew) < timedelta(seconds=2):
            return True
    return False


def timedelta_to_int(td):
    """Takes a timedelta and converts it
    to a single integer that represents its value
    in seconds.  Returns an integer"""
    # because MongoDB cannot store timedeltas
    sec = 0
    t = abs(td)
    sec += t.seconds
    sec += (86400 * t.days)
    if td < timedelta(0):
        sec = -sec
    return sec


def clock_skew_doc(name):
    """Create and return an empty clock skew doc
    for this server"""
    logger = logging.getLogger(__name__)
    logger.debug("creating empty clock skew doc")
    doc = {}
    doc["server_name"] = name
    doc["type"] = "clock_skew"
    doc["partners"] = {}
    return doc

